ifndef::imagesdir[:imagesdir: ../images]

[[section-concepts]]
== Cross-cutting Concepts


ifdef::arc42help[]
[role="arc42help"]
****
.Content
This section describes overall, principal regulations and solution ideas that are relevant in multiple parts (= cross-cutting) of your system.
Such concepts are often related to multiple building blocks.
They can include many different topics, such as

* models, especially domain models
* architecture or design patterns
* rules for using specific technology
* principal, often technical decisions of an overarching (= cross-cutting) nature
* implementation rules


.Motivation
Concepts form the basis for _conceptual integrity_ (consistency, homogeneity) of the architecture. 
Thus, they are an important contribution to achieve inner qualities of your system.

Some of these concepts cannot be assigned to individual building blocks, e.g. security or safety. 


.Form
The form can be varied:

* concept papers with any kind of structure
* cross-cutting model excerpts or scenarios using notations of the architecture views
* sample implementations, especially for technical concepts
* reference to typical usage of standard frameworks (e.g. using Hibernate for object/relational mapping)

.Structure
A potential (but not mandatory) structure for this section could be:

* Domain concepts
* User Experience concepts (UX)
* Safety and security concepts
* Architecture and design patterns
* "Under-the-hood"
* development concepts
* operational concepts

Note: it might be difficult to assign individual concepts to one specific topic
on this list.

image::08-concepts-EN.drawio.png["Possible topics for crosscutting concepts"]


.Further Information

See https://docs.arc42.org/section-8/[Concepts] in the arc42 documentation.
****
endif::arc42help[]

=== Domain concepts
The domain model revolves around the game of Y, a connection strategy game.

* **GameY**: The central entity representing a game session. It holds the state of the triangular board, tracks the current player, and validates rules. It uses a Union-Find data structure to efficiently detect winning paths (connected components touching all three sides) in real-time.
* **Player**: A participant in the game. In this system, a player can be a human (via CLI) or an automated agent (Bot/LLM).
* **Board**: A triangular grid where the game takes place.
* **Coordinates**: A 3-dimensional coordinate system used to uniquely identify cells on the triangular grid.
* **Movement**: Represents a player's turn, which can be placing a piece at a specific point or performing a game action (for example, leaving).
* **Bot**: An AI opponent. The architecture supports pluggable bot strategies, including random moves or integration with Large Language Models (LLMs).

=== Security
* **Input validation and sanitization**: Since the main logic receives external data (via API or CLI), all inputs, especially coordinates and YEN notation strings, are strictly validated before processing to prevent invalid game states.
* **Server authoritativeness**: The frontend (web or CLI) is simply a display layer, and the backend is the game engine. All checks for the legality of moves are applied by the backend to prevent cheating by modified clients.

=== Data persistence and exchange
The system uses a standardized text format for both transporting and storing game data. For persistent storage of application user data, MongoDB is used.

* **YEN Notation (Y Notation)**: The primary format for persisting game state and exchanging messages between subsystems (Web <-> Rust). It uses JSON to represent board size, player turns, and board layout.
* **Serialization/Deserialization**: The system uses serde (in Rust) to strictly map the YEN JSON format to internal memory structures. This ensures that any saved game or network message can be reconstructed into a valid object at runtime.
* **Users Storage**: MongoDB is employed to store user credentials and metadata. The system uses Mongoose schemas to define strict data types and validation rules, ensuring that invalid user data is rejected before reaching the database.

=== Architecture and Design Patterns
The core of the system uses established software engineering patterns to separate the logic from the implementation:

* **Strategy Pattern**: Used for the AI ​​system. The YBot trait acts as a strategy interface, allowing different algorithms (Random, LLM) to be swapped at runtime via YBotRegistry without modifying the game logic.
* **State Machine**: The game flow is modeled as a finite state machine represented by the GameStatus enumeration (e.g., Ongoing, Finished). Transitions are strictly controlled by the results of the moves.
* **Result Pattern**: The system adopts a design where operations do not throw exceptions but rather return success or failure values as part of the normal flow. This forces the architecture to explicitly handle every possible outcome, eliminating "silent failures" and ensuring high reliability.

=== Error Handling and Logging
To ensure maintainability and a transparent user experience, the architecture includes a comprehensive monitoring layer:

* **Semantic Error Handling**: Instead of generic server faults, the system maps internal exceptions to specific, domain-relevant categories (e.g., "Rule Violation," "Resource Unavailable"). This allows client applications to receive meaningful feedback and guide the user towards a solution.

=== User Interface and UX Concepts

* **Internal Logic**: Uses 3D barycentric coordinates (x, y, z) to calculate adjacency and winning paths.
* **Visual/Input**: Uses a linear index (0 to N) or a visual grid mapping for user interactions, simplifying the input process for humans while the backend converts them to 3D coordinates.
* **Feedback Loop**: The user interface provides immediate feedback on the validity of the move based on the results returned by the core logic, ensuring that users understand why a move might be rejected (e.g., "Cell Occupied").